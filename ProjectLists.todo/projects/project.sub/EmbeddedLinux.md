# RK*系列的项目

# RK3506B

### 🚀 RK3506 嵌入式全栈开发：终极进阶版 (含 GUI 深度实战)

#### 第一阶段：环境搭建与基建 (Weeks 1-2)



*目标：打通开发脉络，确保数据在 PC 和开发板之间自由流动。*

- [ ] **1. 基础环境**
  - 任务：阅读 `01【正点原子】ATK-DLRK3506B快速体验V1.1.pdf`，点亮系统。
  - 任务：配置虚拟机与 SSH `02虚拟机...` & `24...VSCode安装...`。
  - 任务：安装交叉编译器 `13...交叉编译器...`。
- [ ] **2. 烧写与网络 (生死攸关)**
  - 任务：熟练掌握 ADB `16...adb工具...` 和 NFS 挂载 `14...NFS搭建...` (这一步没做通，后面开发会痛不欲生)。
  - 任务：配置 `06...Linux网络环境...`，确保板子能 ping 通百度。



#### 第二阶段：应用编程与 GUI 基础 (Weeks 3-4)



*目标：掌握核心 API，跑通最基本的 Hello World 界面。*

- [ ] **1. Linux C 核心**
  - 任务：多线程编程（pthread）与 串口编程（UART）`04...Linux_C应用编程...`。
- [ ] **2. Qt/LVGL 环境准备**
  - 任务：搭建 Qt 开发环境 `09...Qt开发环境搭建...`。
  - 任务：理解 Framebuffer 设备 (`/dev/fb0`) 的基本原理。

------



### 🎨 Phase 2.5：GUI 界面深度实战 (Qt & LVGL 专项扩充) (Weeks 5-9)



*本阶段重点：不仅要“能显示”，还要“不卡顿”、“好看”、“有交互”。*



#### **A. Qt 实战：从工业风到车载仪表的进阶**



*Qt 功能强大但较重，重点在于学习信号槽机制、自定义控件和资源管理。*

- [ ] **项目 1：基于串口的“简易示波器” (工业控制类)**
  - *技术点：Qt Charts 模块或 QPainter 自绘、串口数据解析、多线程数据接收。*
  - 任务：编写一个上位机，通过串口接收 MCU 发来的 ADC 数据。
  - 任务：实时绘制波形图，要求刷新率不低于 20fps。
  - 挑战：实现波形的“暂停”、“缩放”和“数据保存(CSV)”功能。
- [ ] **项目 2：嵌入式 Linux 音乐播放器 (多媒体类)**
  - *技术点：QProcess 调用底层播放器(如 mplayer/aplay) 或 QtMultimedia、列表控件、文件 IO。*
  - 任务：扫描 SD 卡特定目录下的 MP3 文件，显示在 `QListWidget` 中。
  - 任务：实现 播放/暂停/上一曲/下一曲 按钮，并制作一个进度条拖动控制。
  - 挑战：解析 MP3 的 ID3 信息（歌名、专辑封面）并显示在界面上。
- [ ] **项目 3：酷炫车载数字仪表盘 (性能优化类)**
  - *技术点：Qt Quick (QML) vs QWidget 性能对比、旋转动画、SVG 矢量图使用。*
  - 任务：设计一个包含时速表（指针旋转）、转速表和油量显示的界面。
  - 挑战：**极限优化**。RK3506 GPU 较弱，尝试使用 QPainter 的 `setRenderHint(QPainter::Antialiasing)` 对比开启前后的帧率；尝试使用图片序列帧代替实时计算旋转，看哪种更流畅。



#### **B. LVGL 实战：小资源大特效**



*LVGL 是纯 C 语言库，轻量高效，适合在此板子上榨干 CPU 性能。*

- [ ] **项目 4：智能手表/手环 UI (穿戴类)**
  - *技术点：LVGL 对象样式(Style)、事件回调、Tileview (平铺视图)。*
  - 任务：实现一个可上下左右滑动的表盘界面。
  - 任务：主页显示时间（RTC获取），右滑进入计步器界面（模拟数据），下滑进入设置菜单。
  - 挑战：实现“弹性滚动”效果，让界面手感像 Apple Watch 一样丝滑。
- [ ] **项目 5：3D 打印机控制屏幕 (HMI 类)**
  - *技术点：Tabview、复杂的布局 Layout、中文字库生成与显示。*
  - 任务：制作一个包含“打印状态”、“温度曲线”、“文件选择”、“设置”四个标签页的界面。
  - 任务：生成一个自定义的中文字体文件 (Font Converter)，显示“正点原子”等汉字。
- [ ] **项目 6：LVGL 性能压力测试 (极客类)**
  - 任务：运行 LVGL 官方 Benchmark demo。
  - 挑战：修改 `lv_conf.h` 中的显存 buffer 大小、刷新模式 (Full refresh vs Partial refresh)，观察并记录对帧率(FPS)的影响。

------



#### 第三阶段：系统构建与驱动入门 (Weeks 10-12)



*GUI 做完了，你需要更懂底层才能支撑更复杂的应用。*

- [ ] **1. Buildroot 定制**
  - 任务：`21...Buildroot用户手册...`。在 Buildroot `make menuconfig` 中添加自定义的 Qt 或 LVGL 库，而不是用官方打包好的。
  - 任务：设置你的 Qt/LVGL 程序开机自启 `10...创建自启动程序...`。
- [ ] **2. 驱动交互**
  - 任务：编写一个 LED 驱动 `03...Linux驱动开发指南...`。
  - 任务：**联合调试**：在 Qt 界面上做一个开关，按下后通过 `/dev/myled` 控制板载 LED 的亮灭。



#### 第四阶段：硬核移植 - Native Linux + Rootfs (Weeks 13-16)



*脱离舒适区，手动搭建 Linux 发行版。*

- [ ] **1. U-Boot & Kernel 独立编译**
  - 任务：脱离 SDK 脚本，手动编译 Bootloader 和 Kernel。
- [ ] **2. 手搓 Rootfs (Debian/Ubuntu Base)**
  - 任务：使用 `ubuntu-base` 构建根文件系统。
  - 任务：解决依赖问题，手动 `apt install` 安装 `libqt5` 或 `lvgl` 运行库。
  - 挑战：在自己手搓的 Debian 系统上，成功运行你在 Phase 2.5 写的“车载仪表盘”程序。



#### 第五阶段：更多桌面项目计划 (Weeks 17-19)



*在自建系统上玩花活。*

- [ ] **1. 轻量级桌面管理器**
  - 任务：移植 **Fluxbox** 或 **i3wm**，配合 `xinit` 启动。
- [ ] **2. 复古游戏机**
  - 任务：移植 `RetroArch`，测试 NES 模拟器性能。
- [ ] **3. Web Kiosk**
  - 任务：尝试编译运行轻量级浏览器核心，展示 HTML5 界面。



#### 第六阶段：有趣的嵌入式 AI 应用计划 (Weeks 20-24)



*给界面加上“眼睛”和“耳朵”。*

- [ ] **1. NCNN 移植与跑分**
  - 任务：交叉编译腾讯 NCNN 库。
- [ ] **2. AI + GUI 综合大作业：智能安防终端**
  - **核心逻辑**：摄像头采集 -> NCNN 目标检测 (NanoDet) -> 结果画框 -> Qt/LVGL 显示。
  - 任务：当检测到“人”时，在 GUI 界面上亮起红色警报图标，并保存截图到相册目录。
- [ ] **3. 离线语音助手**
  - 任务：移植 Sherpa-ncnn 或 Snowboy。
  - 任务：对着板子说“打开仪表盘”，程序自动切换到 Phase 2.5 做的仪表盘界面。

# Bonus

## 简单/入门（快速可完成、适合熟悉板子与 UI 库）

### 1) 系统状态仪表盘（LVGL）

- 核心点：用 LVGL 做一个实时仪表盘，展示 CPU 占用、内存、温度、网络流量、SD 卡空间、系统日志。

- 技术栈：LVGL（C）、systemd/脚本抓取数据、sqlite 本地日志、shell -> JSON 接口。

- 硬件：HDMI 或 平行 RGB 屏（并行 LCD 支持）。([火火下载](https://download.t-firefly.com/Spec/CoreBorads/Core-3506BY_Core-3506JY_Specification_EN.pdf?utm_source=chatgpt.com))

- 亮点：可做成桌面 Widgets，支持触摸滑动切换面板。

### 2) 触控音乐播放器（Qt 或 Qt for Embedded）

- 核心点：播放本地音乐、ID3 演示、简单波形/频谱可视化、播放列表管理。

- 技术栈：Qt6/C++ 前端，gstreamer 或 ffmpeg 做解码，SQLite 存歌单。

- 硬件：音频 DAC、扬声器、触摸屏。

- 亮点：实现 smooth UI 动画练习 GPU/渲染优化。

### 3) 摄像头滤镜照相亭（LVGL/Qt + OpenCV）

- 核心点：接入 DVP/MIPI 摄像头，实时做灰度/卡通/边缘检测滤镜并拍照保存。

- 技术栈：C++ + OpenCV（或 Python），LVGL/Qt 做 UI。

- 硬件：DVP 摄像头接口（RK3506B 支持 DVP/并行摄像头输入）。([火火下载](https://download.t-firefly.com/Spec/CoreBorads/Core-3506BY_Core-3506JY_Specification_EN.pdf?utm_source=chatgpt.com))

- 亮点：练摄像头获取/缓冲、内存限制下的逐帧处理优化。

------

## 中等（需要更多工程量与优化）

### 4) 离线天气 + 声音闹钟（LVGL + 后端调用）

- 功能：定时闹钟、天气图表（从 Web API 拉取、离线缓存）、语音播报（TTS）。

- 技术栈：LVGL UI；后端 Python/Go 定时任务；TTS 用 eSpeak 或 pico2wave，若需要更自然可接云端或外置 NPU。

- 硬件：Wi-Fi/以太网（RK3506B 提供 RMII 10/100），扬声器、RTC（或系统时间）。([火火下载](https://download.t-firefly.com/Spec/CoreBorads/Core-3506BY_Core-3506JY_Specification_EN.pdf?utm_source=chatgpt.com))

### 5) 本地门铃 + 运动检测（边缘 CV，轻量级）

- 功能：门口检测有人并拍照/本地保存，支持远程通知（MQTT / Webhook）。

- 技术栈：轻量目标检测（TFLite MobileNet SSD-lite int8），OpenCV 做帧差或背景建模做预筛选以节省算力。

- 硬件：DVP 摄像头、GPIO 触发、网络推送。

- 说明：RK3506B CPU 为 A7，单核算力有限，建议使用量化模型或 USB 外置加速器（可选）。([Luckfox Wiki](https://wiki.luckfox.com/assets/files/Rockchip-RK3506B-Datasheet-d913fdb2fbe251cad4a7cbd6363f753f.pdf?utm_source=chatgpt.com))

------

## 大项目（适合个人开发者 3 个月以上 — 我标注为“**大项目**”）

> 这些项目工程量大、需求跨前端/后端/AI/硬件，适合做成作品集或商用 PoC。
>
> 

### 6) **（大项目）便携式 OCR 扫描仪 + 文档管理**

- 核心：支持拍照、自动裁切、透视矫正、OCR（中英混合），导出 PDF，全文检索，UI 支持标注/批注。

- 技术栈：Qt 前端（跨平台界面）或 LVGL（嵌入式轻量界面），后端用 Python （FastAPI）做 OCR 流水线；OCR 用轻量 CRNN/CTC 模型或直接集成 Tesseract（针对 CPU 优化或使用量化模型）。

- 硬件：高分辨率 DVP 摄像头、触摸屏、快速存储（eMMC/SD）。

- 里程碑建议：

  - 硬件摄像头采集 + 图片存储流水线

  - 自动裁剪/透视校正（OpenCV）

  - 集成并优化 OCR（Tesseract + 小型 NN）

  - 本地全文索引（SQLite FTS）

  - UI/UX 打磨与导出 PDF

  - 可选：离线模型量化、USB NPU 支持（加速识别）

- 为什么合适：涉及图像处理、模型优化、UI/UX、文件系统，是完整的大工程。

### 7) **（大项目）智能广告/商品展示交互终端（Qt + 后端 + 推荐系统）**

- 核心：在触摸屏展示目录，支持图像检索（相似商品搜索）、语音/手势交互、后台管理（Web 后台管理商品与推送）。

- 技术栈：Qt 前端（平滑动画、商品 3D 预览可用 WebGL），本地后端用 Node.js/Go 提供 REST API，ML 用轻量检索模型（如 MobileNet 特征 + ANN 索引），推荐用 SQLite 或小型 Elastic-like 索引（Annoy/FAISS）。

- 硬件：触摸屏、摄像头（商品扫码/相机识别）、以太网/Wi-Fi。

- 里程碑建议：

  - 本地商品 DB 与管理接口

  - Qt 前端交互（查询、轮播）

  - 图像特征抽取与相似度检索（量化模型）

  - 后台远程同步与统计模块

  - 性能优化（缩略图缓存、延迟加载）

- 选项：若算力不足可在 LAN 内使用更强的服务器做模型推理，终端做前端和缓存。

### 8) **（大项目）移动控制/感知平台 — 小型机器人（Qt 仪表 + 边缘视觉）**

- 核心：控制底盘、读取传感器（LiDAR/超声/IMU）、摄像头实时物体检测与避障、Qt 可视化面板显示传感器/视频与地图（简易 SLAM）。

- 技术栈：底层用 C/C++ 驱动 PWM、UART、CAN；机器人控制循环（ROS-lite 或自研）；视觉用 OpenCV + 轻量检测模型，Qt 做本地监控界面与遥控。

- 硬件：PWM 驱动、摄像头、IMU、Wi-Fi 遥控；可选外接 LiDAR（通过 UART/I2C）。

- 里程碑建议：

  - 底盘驱动与 Teleop（遥控）

  - 摄像头采集 + 基本视觉处理（障碍检测）

  - 传感器融合与速度控制环

  - 地图构建/简易定位（回环检测可选）

  - Qt 仪表盘 + 视频流 & 控制界面

- 注意：RK3506B CPU 资源有限，复杂 SLAM/深度推理建议使用外部计算或离线/低分辨率策略。

### 9) **（大项目）本地离线语音/视觉多模态家庭助理（LVGL/Qt + 后端 + ASR/TTS）**

- 核心：支持唤醒词（离线）、语音指令识别（ASR）、本地 TTS 回答、摄像头识别人脸/情绪（轻量版），并能调度智能家居（MQTT）、展示信息卡片。

- 技术栈：唤醒/ASR 可用 Vosk / Kaldi-lite 或 Picovoice（若授权），TTS 用 eSpeak 或更好离线模型，视觉用量化模型做人/物检测。后端用 Python 服务编排（FastAPI + MQTT）。

- 硬件：麦克风阵列、扬声器、摄像头、网络模块。

- 里程碑建议：

  - 唤醒词与麦克风采集稳定性调试

  - 离线 ASR 集成与命令映射

  - TTS 与对话管理器（规则型或接入小型 LLM 服务）

  - 视觉模块加入（人脸/情绪）

  - 家居控制与安全/权限策略

- 性能提示：ASR 和视觉在 A7 上需要做非常激进的量化和帧率限制；必要时推荐接入局域网内的更强推理节点或 USB NPU 加速器。

### 10) **（大项目）工业级 HMI + 预测性维护平台（LVGL/Qt + 时间序列 ML）**

- 核心：工业触摸屏 HMI，展示机器状态、报警，收集传感器（温度/振动/电流），做本地/边缘预测性维护（Anomaly Detection）。

- 技术栈：LVGL/Qt 做 HMI，后端用 Python（InfluxDB 或 SQLite + Prometheus 风格指标），时间序列异常检测用 Prophet / tiny LSTM / isolation forest（量化或取样后离线训练），可选云同步。

- 硬件：多路 ADC / Modbus / CAN 接口，触摸屏，工业以太网（RMII 10/100）。

- 里程碑建议：

  - 连接与采集多个传感器（Modbus/RS485/CAN）

  - HMI 页面搭建（控制/趋势/报警）

  - 本地存储 + 同步机制

  - 时间序列异常检测管线（训练/推理分离）

  - 报警策略与报表导出

- 企业级亮点：能满足工控场景、也能作为商业化 PoC。



## 快览（按难度从低到高）

- 复古智能桌面时钟（LVGL） — 小项目（2–4 周）

- 智能化“魔镜”信息面板（LVGL/Qt） — 中等（4–8 周）

- 边缘物体/人形检测摄像头盒（LVGL + AI） — 中等（1–2 个月）

- 便携式游戏机前端 + AI 放大器（Qt） — 中等（1–2 个月）

- 便携 AI 艺术家（相机 + 风格迁移，Qt） — 中等/偏大（6–10 周）

- 大项目①：边缘 AI 智能家居中枢（Qt 前端 + 后端 + AI） — 大（≥3 个月） ★

- 大项目②：无人值守零售/智能自助售货机原型（LVGL/Qt + CV 识别 + 后台） — 大（≥3 个月） ★

- 大项目③：工业级预测性维护平台（采集网关 + 后端 + 可视化） — 大（≥3 个月） ★

- 大项目④：多模态机器人操控台（视频、地图、AI 规划） — 大（≥3 个月） ★

- 大项目⑤：个人离线 AI 笔记/助理（手写识别 + 小型 LLM + 检索） — 大（≥3 个月） ★

------

## 1) 复古智能桌面时钟（LVGL） — 小项目（2–4 周）

- 时钟（本地时间）+ 闹钟管理

- 天气（调用外网 API）展示（如果离线可 mock）

- 触摸翻页动画、主题切换

  **里程碑**（示例）：

- 周1：LVGL 基本布局 + 时间/闹钟逻辑

- 周2：触摸交互 + 动画 + 天气 API

- 周3：打包为 systemd 服务，加入开机自启、优化显示

  **难度**：★☆☆☆

**为什么酷**：低门槛、能快速出 demo，适合熟悉 LVGL 和触摸驱动、显示布局与动画。 **栈**：LVGL（嵌入式 GUI）、C/C++、systemd 服务或简单 Python 后台定时任务。 **外设**：触摸屏、DS18B20 温度(?)、小扬声器（闹钟音）。 **MVP**：

------

## 2) 智能“魔镜”信息面板（LVGL/Qt） — 中等（4–8 周）

- 显示时间、日历、天气、简单快捷操作（播放音乐、灯控）

- 人脸识别：识别用户并显示个性化信息

  **里程碑**：

- 周1–2：UI 设计（LVGL/Qt），本地天气+日历模块

- 周3：摄像头接入 + 人脸识别（ONNX/TensorRT/NN）

- 周4：个性化欢迎与设置面板

  **难度**：★★☆☆

**为什么酷**：外观直观、能整合人脸识别、日程、通知与语音（后续拓展）。 **栈**：LVGL 或 Qt（若要更精美建议 Qt）、后台用 FastAPI/Flask 提供 REST、WebSocket 推送。 **外设**：触摸屏或双面镜、摄像头（人脸识别）、麦克风（可选）。 **AI 用途**：简单人脸识别/签到、情绪/性别/年龄（可选）。 **MVP**：

------

## 3) 边缘物体/人形检测摄像头盒（LVGL + AI） — 中等（4–8 周）

- 实时画面显示 + 目标框识别（人/车/宠物等）

- 告警（本地声音/闪灯 + 可推送到手机）

  **里程碑**：

- 周1：摄像头采集 & LVGL 显示

- 周2：本地推理集成（小模型如 YOLO Nano/ONNX）

- 周3：告警与录像存储、配置界面

  **难度**：★★★☆

**为什么酷**：实用且能练 RK 的 NPU 与模型加速链路（摄像头采集 → 推理 → GUI）。 **栈**：LVGL（状态显示）、后台用 Python（OpenCV + ONNXRuntime/TensorRT / RKNN）、消息可用 MQTT。 **外设**：USB/CSI 摄像头、红外灯（夜视）、按键/LED。 **MVP**：

------

## 4) 便携式游戏机前端 + AI 放大器（Qt） — 中等（4–8 周）

- 支持若干 ROM 的加载、游戏列表、保存/读取状态

- 离线 AI 图像放大工具（对截图/录屏做增强）

  **里程碑**：

- 周1–2：模拟器集成 + Qt 前端（游戏库）

- 周3–4：截图、调用放大模型离线增强，UI 整合

  **难度**：★★★☆

**为什么酷**：复古游戏 + AI 图像增强（实时/离线），界面华丽且易展示。 **栈**：Qt（游戏前端与设置）、RetroArch/libretro（模拟器）、Python/C++ 调用 ESRGAN/ESRGAN-like upscaler（离线或使用 NPU 加速）。 **外设**：手柄、IPS 屏、音频输出、microSD。 **MVP**：

------

## 5) 便携 AI 艺术家 — 相机 + 风格迁移（Qt） — 中等偏大（6–10 周）

- 拍照/导入图片 -> 预设风格一键应用 -> 保存/分享（SFTP 或 HTTP）

  **里程碑**：

- 周1–2：相机采集与 Qt UI

- 周3–5：集成风格迁移模型 & 加速、导出功能

- 周6：图片批处理、滤镜微调、性能优化

  **难度**：★★★☆

**为什么酷**：拍照——> 一键变艺术风格，适合展示 AI 在边缘设备上的创意效果。 **栈**：Qt（界面与图像编辑）、PyTorch/ONNX（风格迁移模型）、ONNXRuntime/TensorRT 或 RKNN 加速。 **外设**：摄像头、触摸屏、Stylus（可选）。 **MVP**：

------

## 6) 大项目①：边缘 AI 智能家居中枢（Qt 前端 + 后端 + AI） — 大（≥3 个月） ★

- 前端：Qt（触控面板） + Web 前端（React/Vue）用于远程

- 后端：FastAPI 或 Go 服务（设备管理、规则引擎、数据库）

- 通讯：MQTT / WebSocket / mDNS（发现）

- AI：本地人脸识别、语音唤醒+离线 ASR、ONNX/TensorRT、RKNN（视 SDK）

  **外设**：触摸屏、摄像头、麦克风阵列、Zigbee/Z-Wave / ESP32 网关（可选）。 **MVP（3 个月版本）**：

- 设备发现与控制（灯、插座）、情景模式（早/晚）、本地用户管理（人脸）

- Web 控制面板 + 本地触控面板（Qt）

- 简单语音唤醒（离线）与语音命令（开灯/关灯）

  **里程碑（建议）**：

- 月1：设备通信层（MQTT/REST）+ 数据模型 + Qt 基本 UI

- 月2：设备管理、场景逻辑、Web 前端 + 安全（认证）

- 月3：人脸识别/语音基础集成、自动化规则、性能优化与打包镜像

  **扩展/Stretch**：能耗优化、远程 OTA、第三方云集成（选配） **难度**：★★★★☆

**为什么酷**：把 RK3588 当作家中的智能大脑，集成多设备、语音、视觉、自动化规则与 Web/手机控制，作品含金量高。 **栈**：

------

## 7) 大项目②：无人值守零售/智能自助售货机原型 — 大（≥3 个月） ★

- 前端：LVGL（售货机触控）或 Qt（更复杂界面）

- 后端：FastAPI + PostgreSQL + RabbitMQ（订单队列）

- AI：商品识别、异常检测、付款人脸匹配（可选），模型 ONNX/TensorRT/RKNN。

  **外设**：触摸屏、摄像头、扫码器、付费模块（读卡/扫码）、货道控制（继电器）。 **MVP**：

- 商品展示与扫码支付流程（模拟支付或微信/支付宝 SDK）

- 摄像头进行上货/下货识别 + 后台库存同步

  **里程碑**：

- 月1：界面与商品管理、DB 设计、基本支付流程（模拟）

- 月2：摄像头识别上货/下货、告警、库存对账

- 月3：实际支付接入、日志审计、异常处理、封装系统镜像

  **难度**：★★★★☆

**为什么酷**：实战性强，结合 CV（商品识别）、支付前端、库存管理与后台分析。商业上也有价值。 **栈**：

------

## 8) 大项目③：工业预测性维护平台（采集网关 + 后端 + 可视化） — 大（≥3 个月） ★

- 现场网关：C++/Python（数据采集，Modbus/OPC-UA 支持） + SQLite/InfluxDB（本地缓存）

- 后端：时序数据库（InfluxDB）、数据处理（Python/Go）、模型（异常检测、时序预测）

- 前端：Web（Grafana/自研 React Dashboard）或 Qt 可视化面板

  **AI 用途**：振动/温度/电流的异常检测（Autoencoder/TS forecasting）、滚动窗口特征抽取。 **MVP**：

- 设备接入、时序数据上报、基础告警（阈值）

- 边缘模型部署用于异常检测并触发告警

  **里程碑**：

- 月1：采集层 + 本地存储 + 简单 Dashboard

- 月2：模型训练流程（离线）+ 部署到边缘推理

- 月3：告警、历史回溯、部署与稳定性优化

  **难度**：★★★★☆

**为什么酷**：将 RK3588 作为现场网关采集高频数据并做边缘预处理/模型推断，组合可视化与报警体系，具有工程背景深度。 **栈**：

------

## 9) 大项目④：多模态机器人操控台（视频、地图、AI 规划） — 大（≥3 个月） ★

- 前端：Qt（高帧率视频流、可交互地图、任务面板）

- 中间层：ROS2 或自研消息层（视频/telemetry）

- 后端：路径规划服务、任务调度、日志存储

- AI：目标检测、语义分割、运动预测、行为规划（ONNX/RT）

  **外设**：Wi-Fi/5G 链路、摄像头、LiDAR（可选）、操控摇杆。 **MVP**：

- 实时视频流 + 遥控 + 基础地图显示（位置信息）

- 简单的 AI 辅助（自动避障或自动导航到点）

  **里程碑**：

- 月1：视频、telemetry 通道、Qt 显示与操控

- 月2：集成 ROS2（或消息层）+ 基础自动化（避障）

- 月3：路径规划、任务队列、多机扩展与日志回放

  **难度**：★★★★★

**为什么酷**：面向机器人/无人车操控，整合实时视频、地图、遥控、AI 路径/任务规划，展示高并发数据流与交互设计能力。 **栈**：

------

## 10) 大项目⑤：个人离线 AI 笔记/助理（手写识别 + 小型 LLM + 检索） — 大（≥3 个月） ★

- 前端：Qt（富文本 + 手写笔输入）+ Web（同步/导出）

- 后端：FastAPI、SQLite/Whoosh/FAISS（向量检索）

- AI：手写识别（OCR/Transformer）、小型 quantized LLM（轻量问答）、向量检索 + RAG。模型以 ONNX/量化形式部署或使用 RK NPU 加速（视 SDK）。

  **MVP**：

- 手写笔记识别为文本，支持全文检索与标签化

- 简单离线问答（基于本地向量检索的短回答）

  **里程碑**：

- 月1：手写输入 + 基本 OCR 流程 + 文本存储/索引

- 月2：向量化检索、基础 LLM 集成（小型模型）、查询界面

- 月3：RAG 流程、跨设备同步（加密）、性能优化

  **难度**：★★★★☆

**为什么酷**：把 RK3588 做成个人隐私优先的笔记与智能助理终端：手写 OCR、语音/文本输入、本地检索式问答（RAG）与可视化笔记管理。学术/作品都很吸睛。 **栈**：

------

## 工程建议（适用于以上所有项目）

- **模型加速**：优先将模型导成 ONNX，再看能否用 TensorRT / ONNXRuntime + NPU SDK（RKNN）做加速。RK3588 带 NPU，很适合离线推理。

- **镜像化部署**：把服务与模型做成容器镜像（或至少制作系统镜像），便于复现与分发。

- **模块化设计**：前端（GUI） 和 后端（服务/AI/DB）清晰隔离，使用 REST/WebSocket 通信，方便后续替换或扩展。

- **日志与 OTA**：长期项目要早规划日志、远程调试通道与 OTA 升级策略。

- **性能/功耗**：在开发早期就做性能基准（FPS、推理延迟、温度、功耗），避免后期才发现瓶颈。

# RK3588

# RK3588学习计划

### 🗓️ 阶段一：基础夯实与厂商 SDK 复现（Week 1 - Week 6）



**核心目标：** 不做无头苍蝇，完全掌控厂商提供的标准环境，打通开发链路。



#### Week 1：开箱、环境与“Hello World”



*本周重点：建立连接，确保板子是活的。*

- [ ] **环境准备**
  - [ ] 收到开发板，检查外观无损。
  - [ ] 购买/准备配件：USB-TTL 线、PD 电源（确保功率足够）、Mini HDMI 线、高质量 SD 卡（Class10+）。
  - [ ] 主机（PC）安装 Ubuntu 20.04/22.04（虚拟机或 WSL2），配置国内 apt 源。
  - [ ] 主机安装基础工具：`sudo apt install build-essential git python3 minicom adb`。
- [ ] **系统烧写**
  - [ ] 下载厂商提供的 DriverAssitant（驱动助手）并安装。
  - [ ] 下载 AndroidTool (RKDevTool) 烧写工具。
  - [ ] 下载官方提供的 Ubuntu 预编译镜像。
  - [ ] 按住 Maskrom/Recovery 键上电，识别 USB 设备，完成首次烧写。
- [ ] **连接与验证**
  - [ ] 连接串口（波特率 1500000 或 115200，视厂商而定），使用 Minicom/Putty 打开。
  - [ ] 观察 U-Boot 和 Kernel 启动时的“瀑布流”日志，截图保存正常启动的样子。
  - [ ] 登录系统（默认账号通常是 root/rockchip 或 pi）。
  - [ ] 连接网线/WiFi，`ping www.baidu.com` 确认联网。
  - [ ] 配置 SSH：`sudo systemctl enable ssh`，记录板子 IP。
- [ ] **开发环境联调**
  - [ ] VSCode 安装 "Remote - SSH" 插件。
  - [ ] 配置 `~/.ssh/config` 实现免密登录。
  - [ ] 在板子上写一个 C 语言 Hello World，用 `gcc` 本地编译运行成功。



#### Week 2：SDK 源码全量编译（由点到面）



*本周重点：理解“镜像”是怎么来的。*

- [ ] **获取源码**
  - [ ] 注册厂商 Git 权限或下载源码压缩包（通常 100GB+，准备好硬盘空间）。
  - [ ] 运行 `repo sync` 或解压命令，确保目录结构完整。
- [ ] **编译环境搭建**
  - [ ] 运行厂商提供的 `install_dependencies.sh` 或手动安装几百个依赖包。
  - [ ] 配置交叉编译链路径（`export PATH=...`）。
- [ ] **分步编译测试**
  - [ ] **U-Boot 编译**：执行 build 脚本编译 uboot，生成 `uboot.img`。
  - [ ] **Kernel 编译**：编译内核，生成 `boot.img`。
  - [ ] **Rootfs 编译**：构建 Debian/Ubuntu 文件系统（最耗时）。
  - [ ] **全量打包**：生成 `update.img`。
- [ ] **验证成果**
  - [ ] 将自己编译的镜像烧录到板子。
  - [ ] **关键验收**：修改 Kernel 源码中的 `Makefile` 版本号（加个后缀），烧录后运行 `uname -a`，看到自己的名字才算成功。



#### Week 3：U-Boot 魔改与内核剪裁



- [ ] **U-Boot 探索**
  - [ ] 进入 U-Boot 命令行模式（启动时狂按 Ctrl+C）。
  - [ ] 练习命令：`printenv`, `setenv`, `saveenv`, `boot`。
  - [ ] 任务：修改启动倒计时 `bootdelay` 为 10 秒，并修改默认启动参数。
  - [ ] 进阶：修改 U-Boot 源码，替换开机 Logo 为自己喜欢的图片。
- [ ] **内核配置**
  - [ ] 在 SDK 根目录运行 `make menuconfig`。
  - [ ] 任务：找到一个你不用的驱动（如某个 WiFi 模块），将其取消编译。
  - [ ] 任务：修改 Kernel 启动 Logo（企鹅图标）。
  - [ ] 重新编译并烧录，验证改动生效。



#### Week 4：设备树 (DTS) 与 硬件控制



*本周重点：理解 Linux 如何描述硬件。*

- [ ] **DTS 理论**
  - [ ] 阅读内核源码目录下的 `arch/arm64/boot/dts/rockchip/rk3588-*.dts`。
  - [ ] 理解 `status = "okay" / "disabled"` 的含义。
- [ ] **GPIO 实战**
  - [ ] 找出手册中的 GPIO 引脚定义（如 GPIO3_A1）。
  - [ ] 修改 DTS，将该引脚配置为输出模式，关联一个 LED（如果没有 LED，用万用表测电压）。
  - [ ] 编译并替换 DTB 文件（无需重刷整个固件）。
  - [ ] 在 `/sys/class/gpio` 下控制该引脚高低电平。
- [ ] **I2C/UART 启用**
  - [ ] 在 DTS 中开启一个未使用的 I2C 节点。
  - [ ] 使用 `i2cdetect -y <bus>` 扫描挂载的设备。



#### Week 5：内核模块与驱动入门



- [ ] **Hello Kernel Module**
  - [ ] 编写一个 `hello_module.c`，包含 `module_init` 和 `module_exit`。
  - [ ] 编写 Makefile，使用交叉编译链编译出 `.ko` 文件。
  - [ ] 将 `.ko` 传到板子，运行 `insmod`, `lsmod`, `rmmod`，查看 `dmesg` 输出。
- [ ] **字符设备驱动**
  - [ ] 编写一个简单的字符设备驱动，注册 `/dev/my_device`。
  - [ ] 编写用户态 App，对该设备进行 read/write 操作，观察驱动日志。



#### Week 6：多媒体入门（摄像头与 ISP）



- [ ] **摄像头点亮**
  - [ ] 连接 MIPI 摄像头（如 IMX415）。
  - [ ] 检查 `/dev/video*` 节点是否出现。
  - [ ] 使用 `v4l2-ctl --list-formats-ext` 查看支持的格式。
  - [ ] 使用 `media-ctl -p` 查看拓扑结构。
- [ ] **图像抓取**
  - [ ] 使用命令抓图：`v4l2-ctl -d /dev/video11 --set-fmt-video=width=3840,height=2160,pixelformat=NV12 --stream-mmap --stream-count=1 --stream-to=test.raw`。
  - [ ] 使用 YUV 查看器（如 7yuv）在 PC 上查看抓取的图片是否正常。
  - [ ] 尝试运行厂商提供的 `rkisp_demo`。

------



### 🗓️ 阶段二：进阶应用与 AI 部署（Week 7 - Week 12）



**核心目标：** 利用 RK3588 强大的 NPU 和编解码能力做实际应用。



#### Week 7：硬件编解码（MPP）与 RGA



- [ ] **MPP (Media Process Platform) 学习**
  - [ ] 编译 `mpp` 库 demo。
  - [ ] 运行 `mpi_dec_test`，测试 H.264/H.265 硬解码性能。
  - [ ] 运行 `mpi_enc_test`，测试摄像头数据硬编码为 H.264 文件。
- [ ] **RGA (2D 图形加速) 实战**
  - [ ] 编写程序，使用 RGA 对一张 4K 图片进行缩放、裁剪、格式转换（NV12 转 RGB）。
  - [ ] 对比 CPU 软转（OpenCV）与 RGA 硬转的耗时差异（通常 RGA 快几十倍）。



#### Week 8：RKNN 基础与模型转换



- [ ] **环境搭建**
  - [ ] 在 PC 上安装 `rknn-toolkit2` (Python 环境)。
  - [ ] 下载 YOLOv5 或 MobileNet 的 ONNX 模型。
- [ ] **模型转换**
  - [ ] 编写 Python 脚本，将 ONNX 转换为 `.rknn` 格式。
  - [ ] 理解量化（Quantization）：fp16 vs i8，生成不同精度的模型。
- [ ] **板端推理**
  - [ ] 编译厂商提供的 `rknn_yolov5_demo`。
  - [ ] 在板子上运行推理，记录单帧耗时（Time per inference）。



#### Week 9：综合项目 I - 智能监控 Web 端



- [ ] **架构设计**
  - [ ] 后端：Python Flask/FastAPI 或 C++ Crow。
  - [ ] 流程：OpenCV/GStreamer 取流 -> RGA 预处理 -> RKNN 推理 -> 画框 -> 推流。
- [ ] **功能实现**
  - [ ] 搭建 Web 页面，显示实时视频流（使用 MJPEG 流最简单）。
  - [ ] 将 NPU 检测结果（人、车）叠加在视频上。
  - [ ] **验收**：浏览器打开 IP:Port 能看到画面，延迟小于 500ms。



#### Week 10：综合项目 II - Qt6 嵌入式仪表盘



- [ ] **Qt 环境**
  - [ ] 使用 Buildroot 或厂商 SDK 编译带 Qt6 库的 Rootfs。
  - [ ] 配置 Qt Creator 交叉编译环境。
- [ ] **界面开发**
  - [ ] 设计一个汽车仪表盘或工控界面。
  - [ ] 读取系统信息（CPU 温度、频率）并显示。
  - [ ] 嵌入摄像头预览窗口（使用 QtMultimedia 或 QWidget 绘制 RGA 结果）。
- [ ] **性能优化**
  - [ ] 确保界面运行在 GPU 上（EGLFS 模式），而不是 CPU 渲染。



#### Week 11：Docker 与 边缘服务化



- [ ] **容器化**
  - [ ] 在板子上安装 Docker。
  - [ ] 解决 Docker 内访问 `/dev/mpp_service` 和 `/dev/npu` 的权限问题（Privileged 模式或映射设备）。
- [ ] **微服务封装**
  - [ ] 将 Week 8 的 AI 推理程序封装成 Docker 镜像。
  - [ ] 编写 Dockerfile，实现开机自动拉起推理服务，提供 REST API 接口。



#### Week 12：阶段复盘与产品化思维



- [ ] **文档整理**：整理所有代码，上传 GitHub。
- [ ] **自动化脚本**：编写 `deploy.sh`，一键在干净的板子上部署你的环境。
- [ ] **演示视频**：录制你的 Qt 桌面和 AI 识别效果。

------



### 🚀 阶段三：硬核拓展 - 原生移植与前沿探索（Week 13 - Week 20）



**核心目标：** 脱离厂商 SDK 的“保姆式”喂养，自己构建 Linux 发行版，并运行高阶 AI/桌面项目。



#### Week 13：原生 Linux 根文件系统构建 (Debian/Ubuntu Base)



*挑战：不使用 Rockchip 提供的 rootfs，自己用 debootstrap 从零构建。*

- [ ] **构建 Base System**
  - [ ] 使用 `ubuntu-base` 或 `debootstrap` 构建一个最小的 ARM64 文件系统。
  - [ ]通过 `chroot` 进入文件系统，安装 apt, network-manager, ssh 等基础包。
  - [ ] 配置用户、主机名、fstab。
- [ ] **移植厂商内核与模块**
  - [ ] 将 Week 2 编译好的 Kernel 和 Modules 安装到这个新 Rootfs 中。
  - [ ] 修复 firmwares 缺失问题（拷贝 `/lib/firmware`）。
- [ ] **验收**：板子能启动进入这个纯净的 Ubuntu/Debian，且 WiFi/以太网正常。



#### Week 14：移植 Arch Linux ARM (Manjaro 风格)



*挑战：体验滚动发行版的魅力，熟悉 pacman。*

- [ ] 下载 Arch Linux ARM 通用包。
- [ ] 手动通过 pacman 安装 Rockchip 相关的包（如果源里有）或者手动替换 Kernel。
- [ ] 配置 Systemd-networkd。
- [ ] 成功运行并安装 `neofetch` 截图装逼。



#### Week 15：桌面环境移植 (Gnome/KDE vs Wayland)



*挑战：在自己构建的系统上跑通图形界面。*

- [ ] **X11/Wayland 抉择**
  - [ ] 安装 Weston (Wayland 参考实现)，验证 GPU 驱动（Mali）是否工作正常（glmark2-es2跑分）。
- [ ] **重型桌面**
  - [ ] `apt install gnome-shell` 或 `kde-plasma`。
  - [ ] 解决 GDM/SDDM 启动黑屏问题（通常涉及 DRM 驱动配置）。
- [ ] **Panfrost 探索 (可选)**
  - [ ] 尝试使用开源 GPU 驱动 Panfrost 代替厂商闭源驱动（注意：性能可能下降，但更自由）。



#### Week 16：嵌入式大模型 (LLM on Edge) 🔥



*目标：在 RK3588 上运行 ChatGPT 级别的本地模型。*

- [ ] **RKLLM 工具链**
  - [ ] 下载 Rockchip 最新的 RKLLM SDK。
  - [ ] 下载 Qwen-1.8B-Chat 或 Llama2-7B (量化版) 模型。
- [ ] **模型转换与部署**
  - [ ] 将 HuggingFace 模型转换为 RKLLM 格式。
  - [ ] 编写 C++ 推理 demo，在 NPU 上运行。
- [ ] **性能测试**
  - [ ] 达到 10 tokens/s 以上的生成速度即为流畅。



#### Week 17：语音交互助理 (ASR + TTS + LLM)



- [ ] **语音识别 (ASR)**
  - [ ] 移植 Sherpa-ncnn 或 Vosk 到 RK3588（利用 CPU 或 NPU）。
  - [ ] 实现麦克风阵列读取与唤醒词检测。
- [ ] **语音合成 (TTS)**
  - [ ] 移植 Piper 或 VITS (跑在 CPU 上即可)。
- [ ] **全链路打通**
  - [ ] 说话 -> 转文字 -> 发送给 Week 16 的 LLM -> 获取文本 -> TTS 读出。
  - [ ] 打造一个离线的“贾维斯”原型。



#### Week 18：ROS 2 机器人系统基础



- [ ] **ROS 2 安装**
  - [ ] 在 Ubuntu 环境下安装 ROS 2 Humble。
  - [ ] 运行 `turtlesim` 验证通信。
- [ ] **感知节点**
  - [ ] 编写 ROS 2 Node，读取摄像头数据。
  - [ ] 编写另一个 Node，调用 RKNN 进行目标检测，发布 Topic。
  - [ ] 在 PC 上用 Rviz 远程订阅并可视化板子上的检测结果。



#### Week 19：复古游戏机与娱乐系统

- [ ] **RetroArch / Batocera 移植**
  - [ ] 编译 RetroArch 及其 Cores。
  - [ ] 配置手柄输入。
  - [ ] 测试 PSP/N64 模拟器性能（RK3588 跑这些非常流畅）。
- [ ] **Kodi 媒体中心**
  - [ ] 编译支持 MPP 硬解的 Kodi。
  - [ ] 打造一台 4K 电视机顶盒。

