# RK3588学习计划

### 🗓️ 阶段一：基础夯实与厂商 SDK 复现（Week 1 - Week 6）



**核心目标：** 不做无头苍蝇，完全掌控厂商提供的标准环境，打通开发链路。



#### Week 1：开箱、环境与“Hello World”



*本周重点：建立连接，确保板子是活的。*

- [ ] **环境准备**
  - [ ] 收到开发板，检查外观无损。
  - [ ] 购买/准备配件：USB-TTL 线、PD 电源（确保功率足够）、Mini HDMI 线、高质量 SD 卡（Class10+）。
  - [ ] 主机（PC）安装 Ubuntu 20.04/22.04（虚拟机或 WSL2），配置国内 apt 源。
  - [ ] 主机安装基础工具：`sudo apt install build-essential git python3 minicom adb`。
- [ ] **系统烧写**
  - [ ] 下载厂商提供的 DriverAssitant（驱动助手）并安装。
  - [ ] 下载 AndroidTool (RKDevTool) 烧写工具。
  - [ ] 下载官方提供的 Ubuntu 预编译镜像。
  - [ ] 按住 Maskrom/Recovery 键上电，识别 USB 设备，完成首次烧写。
- [ ] **连接与验证**
  - [ ] 连接串口（波特率 1500000 或 115200，视厂商而定），使用 Minicom/Putty 打开。
  - [ ] 观察 U-Boot 和 Kernel 启动时的“瀑布流”日志，截图保存正常启动的样子。
  - [ ] 登录系统（默认账号通常是 root/rockchip 或 pi）。
  - [ ] 连接网线/WiFi，`ping www.baidu.com` 确认联网。
  - [ ] 配置 SSH：`sudo systemctl enable ssh`，记录板子 IP。
- [ ] **开发环境联调**
  - [ ] VSCode 安装 "Remote - SSH" 插件。
  - [ ] 配置 `~/.ssh/config` 实现免密登录。
  - [ ] 在板子上写一个 C 语言 Hello World，用 `gcc` 本地编译运行成功。



#### Week 2：SDK 源码全量编译（由点到面）



*本周重点：理解“镜像”是怎么来的。*

- [ ] **获取源码**
  - [ ] 注册厂商 Git 权限或下载源码压缩包（通常 100GB+，准备好硬盘空间）。
  - [ ] 运行 `repo sync` 或解压命令，确保目录结构完整。
- [ ] **编译环境搭建**
  - [ ] 运行厂商提供的 `install_dependencies.sh` 或手动安装几百个依赖包。
  - [ ] 配置交叉编译链路径（`export PATH=...`）。
- [ ] **分步编译测试**
  - [ ] **U-Boot 编译**：执行 build 脚本编译 uboot，生成 `uboot.img`。
  - [ ] **Kernel 编译**：编译内核，生成 `boot.img`。
  - [ ] **Rootfs 编译**：构建 Debian/Ubuntu 文件系统（最耗时）。
  - [ ] **全量打包**：生成 `update.img`。
- [ ] **验证成果**
  - [ ] 将自己编译的镜像烧录到板子。
  - [ ] **关键验收**：修改 Kernel 源码中的 `Makefile` 版本号（加个后缀），烧录后运行 `uname -a`，看到自己的名字才算成功。



#### Week 3：U-Boot 魔改与内核剪裁



- [ ] **U-Boot 探索**
  - [ ] 进入 U-Boot 命令行模式（启动时狂按 Ctrl+C）。
  - [ ] 练习命令：`printenv`, `setenv`, `saveenv`, `boot`。
  - [ ] 任务：修改启动倒计时 `bootdelay` 为 10 秒，并修改默认启动参数。
  - [ ] 进阶：修改 U-Boot 源码，替换开机 Logo 为自己喜欢的图片。
- [ ] **内核配置**
  - [ ] 在 SDK 根目录运行 `make menuconfig`。
  - [ ] 任务：找到一个你不用的驱动（如某个 WiFi 模块），将其取消编译。
  - [ ] 任务：修改 Kernel 启动 Logo（企鹅图标）。
  - [ ] 重新编译并烧录，验证改动生效。



#### Week 4：设备树 (DTS) 与 硬件控制



*本周重点：理解 Linux 如何描述硬件。*

- [ ] **DTS 理论**
  - [ ] 阅读内核源码目录下的 `arch/arm64/boot/dts/rockchip/rk3588-*.dts`。
  - [ ] 理解 `status = "okay" / "disabled"` 的含义。
- [ ] **GPIO 实战**
  - [ ] 找出手册中的 GPIO 引脚定义（如 GPIO3_A1）。
  - [ ] 修改 DTS，将该引脚配置为输出模式，关联一个 LED（如果没有 LED，用万用表测电压）。
  - [ ] 编译并替换 DTB 文件（无需重刷整个固件）。
  - [ ] 在 `/sys/class/gpio` 下控制该引脚高低电平。
- [ ] **I2C/UART 启用**
  - [ ] 在 DTS 中开启一个未使用的 I2C 节点。
  - [ ] 使用 `i2cdetect -y <bus>` 扫描挂载的设备。



#### Week 5：内核模块与驱动入门



- [ ] **Hello Kernel Module**
  - [ ] 编写一个 `hello_module.c`，包含 `module_init` 和 `module_exit`。
  - [ ] 编写 Makefile，使用交叉编译链编译出 `.ko` 文件。
  - [ ] 将 `.ko` 传到板子，运行 `insmod`, `lsmod`, `rmmod`，查看 `dmesg` 输出。
- [ ] **字符设备驱动**
  - [ ] 编写一个简单的字符设备驱动，注册 `/dev/my_device`。
  - [ ] 编写用户态 App，对该设备进行 read/write 操作，观察驱动日志。



#### Week 6：多媒体入门（摄像头与 ISP）



- [ ] **摄像头点亮**
  - [ ] 连接 MIPI 摄像头（如 IMX415）。
  - [ ] 检查 `/dev/video*` 节点是否出现。
  - [ ] 使用 `v4l2-ctl --list-formats-ext` 查看支持的格式。
  - [ ] 使用 `media-ctl -p` 查看拓扑结构。
- [ ] **图像抓取**
  - [ ] 使用命令抓图：`v4l2-ctl -d /dev/video11 --set-fmt-video=width=3840,height=2160,pixelformat=NV12 --stream-mmap --stream-count=1 --stream-to=test.raw`。
  - [ ] 使用 YUV 查看器（如 7yuv）在 PC 上查看抓取的图片是否正常。
  - [ ] 尝试运行厂商提供的 `rkisp_demo`。

------



### 🗓️ 阶段二：进阶应用与 AI 部署（Week 7 - Week 12）



**核心目标：** 利用 RK3588 强大的 NPU 和编解码能力做实际应用。



#### Week 7：硬件编解码（MPP）与 RGA



- [ ] **MPP (Media Process Platform) 学习**
  - [ ] 编译 `mpp` 库 demo。
  - [ ] 运行 `mpi_dec_test`，测试 H.264/H.265 硬解码性能。
  - [ ] 运行 `mpi_enc_test`，测试摄像头数据硬编码为 H.264 文件。
- [ ] **RGA (2D 图形加速) 实战**
  - [ ] 编写程序，使用 RGA 对一张 4K 图片进行缩放、裁剪、格式转换（NV12 转 RGB）。
  - [ ] 对比 CPU 软转（OpenCV）与 RGA 硬转的耗时差异（通常 RGA 快几十倍）。



#### Week 8：RKNN 基础与模型转换



- [ ] **环境搭建**
  - [ ] 在 PC 上安装 `rknn-toolkit2` (Python 环境)。
  - [ ] 下载 YOLOv5 或 MobileNet 的 ONNX 模型。
- [ ] **模型转换**
  - [ ] 编写 Python 脚本，将 ONNX 转换为 `.rknn` 格式。
  - [ ] 理解量化（Quantization）：fp16 vs i8，生成不同精度的模型。
- [ ] **板端推理**
  - [ ] 编译厂商提供的 `rknn_yolov5_demo`。
  - [ ] 在板子上运行推理，记录单帧耗时（Time per inference）。



#### Week 9：综合项目 I - 智能监控 Web 端



- [ ] **架构设计**
  - [ ] 后端：Python Flask/FastAPI 或 C++ Crow。
  - [ ] 流程：OpenCV/GStreamer 取流 -> RGA 预处理 -> RKNN 推理 -> 画框 -> 推流。
- [ ] **功能实现**
  - [ ] 搭建 Web 页面，显示实时视频流（使用 MJPEG 流最简单）。
  - [ ] 将 NPU 检测结果（人、车）叠加在视频上。
  - [ ] **验收**：浏览器打开 IP:Port 能看到画面，延迟小于 500ms。



#### Week 10：综合项目 II - Qt6 嵌入式仪表盘



- [ ] **Qt 环境**
  - [ ] 使用 Buildroot 或厂商 SDK 编译带 Qt6 库的 Rootfs。
  - [ ] 配置 Qt Creator 交叉编译环境。
- [ ] **界面开发**
  - [ ] 设计一个汽车仪表盘或工控界面。
  - [ ] 读取系统信息（CPU 温度、频率）并显示。
  - [ ] 嵌入摄像头预览窗口（使用 QtMultimedia 或 QWidget 绘制 RGA 结果）。
- [ ] **性能优化**
  - [ ] 确保界面运行在 GPU 上（EGLFS 模式），而不是 CPU 渲染。



#### Week 11：Docker 与 边缘服务化



- [ ] **容器化**
  - [ ] 在板子上安装 Docker。
  - [ ] 解决 Docker 内访问 `/dev/mpp_service` 和 `/dev/npu` 的权限问题（Privileged 模式或映射设备）。
- [ ] **微服务封装**
  - [ ] 将 Week 8 的 AI 推理程序封装成 Docker 镜像。
  - [ ] 编写 Dockerfile，实现开机自动拉起推理服务，提供 REST API 接口。



#### Week 12：阶段复盘与产品化思维



- [ ] **文档整理**：整理所有代码，上传 GitHub。
- [ ] **自动化脚本**：编写 `deploy.sh`，一键在干净的板子上部署你的环境。
- [ ] **演示视频**：录制你的 Qt 桌面和 AI 识别效果。

------



### 🚀 阶段三：硬核拓展 - 原生移植与前沿探索（Week 13 - Week 20）



**核心目标：** 脱离厂商 SDK 的“保姆式”喂养，自己构建 Linux 发行版，并运行高阶 AI/桌面项目。



#### Week 13：原生 Linux 根文件系统构建 (Debian/Ubuntu Base)



*挑战：不使用 Rockchip 提供的 rootfs，自己用 debootstrap 从零构建。*

- [ ] **构建 Base System**
  - [ ] 使用 `ubuntu-base` 或 `debootstrap` 构建一个最小的 ARM64 文件系统。
  - [ ]通过 `chroot` 进入文件系统，安装 apt, network-manager, ssh 等基础包。
  - [ ] 配置用户、主机名、fstab。
- [ ] **移植厂商内核与模块**
  - [ ] 将 Week 2 编译好的 Kernel 和 Modules 安装到这个新 Rootfs 中。
  - [ ] 修复 firmwares 缺失问题（拷贝 `/lib/firmware`）。
- [ ] **验收**：板子能启动进入这个纯净的 Ubuntu/Debian，且 WiFi/以太网正常。



#### Week 14：移植 Arch Linux ARM (Manjaro 风格)



*挑战：体验滚动发行版的魅力，熟悉 pacman。*

- [ ] 下载 Arch Linux ARM 通用包。
- [ ] 手动通过 pacman 安装 Rockchip 相关的包（如果源里有）或者手动替换 Kernel。
- [ ] 配置 Systemd-networkd。
- [ ] 成功运行并安装 `neofetch` 截图装逼。



#### Week 15：桌面环境移植 (Gnome/KDE vs Wayland)



*挑战：在自己构建的系统上跑通图形界面。*

- [ ] **X11/Wayland 抉择**
  - [ ] 安装 Weston (Wayland 参考实现)，验证 GPU 驱动（Mali）是否工作正常（glmark2-es2跑分）。
- [ ] **重型桌面**
  - [ ] `apt install gnome-shell` 或 `kde-plasma`。
  - [ ] 解决 GDM/SDDM 启动黑屏问题（通常涉及 DRM 驱动配置）。
- [ ] **Panfrost 探索 (可选)**
  - [ ] 尝试使用开源 GPU 驱动 Panfrost 代替厂商闭源驱动（注意：性能可能下降，但更自由）。



#### Week 16：嵌入式大模型 (LLM on Edge) 🔥



*目标：在 RK3588 上运行 ChatGPT 级别的本地模型。*

- [ ] **RKLLM 工具链**
  - [ ] 下载 Rockchip 最新的 RKLLM SDK。
  - [ ] 下载 Qwen-1.8B-Chat 或 Llama2-7B (量化版) 模型。
- [ ] **模型转换与部署**
  - [ ] 将 HuggingFace 模型转换为 RKLLM 格式。
  - [ ] 编写 C++ 推理 demo，在 NPU 上运行。
- [ ] **性能测试**
  - [ ] 达到 10 tokens/s 以上的生成速度即为流畅。



#### Week 17：语音交互助理 (ASR + TTS + LLM)



- [ ] **语音识别 (ASR)**
  - [ ] 移植 Sherpa-ncnn 或 Vosk 到 RK3588（利用 CPU 或 NPU）。
  - [ ] 实现麦克风阵列读取与唤醒词检测。
- [ ] **语音合成 (TTS)**
  - [ ] 移植 Piper 或 VITS (跑在 CPU 上即可)。
- [ ] **全链路打通**
  - [ ] 说话 -> 转文字 -> 发送给 Week 16 的 LLM -> 获取文本 -> TTS 读出。
  - [ ] 打造一个离线的“贾维斯”原型。



#### Week 18：ROS 2 机器人系统基础



- [ ] **ROS 2 安装**
  - [ ] 在 Ubuntu 环境下安装 ROS 2 Humble。
  - [ ] 运行 `turtlesim` 验证通信。
- [ ] **感知节点**
  - [ ] 编写 ROS 2 Node，读取摄像头数据。
  - [ ] 编写另一个 Node，调用 RKNN 进行目标检测，发布 Topic。
  - [ ] 在 PC 上用 Rviz 远程订阅并可视化板子上的检测结果。



#### Week 19：复古游戏机与娱乐系统



- [ ] **RetroArch / Batocera 移植**
  - [ ] 编译 RetroArch 及其 Cores。
  - [ ] 配置手柄输入。
  - [ ] 测试 PSP/N64 模拟器性能（RK3588 跑这些非常流畅）。
- [ ] **Kodi 媒体中心**
  - [ ] 编译支持 MPP 硬解的 Kodi。
  - [ ] 打造一台 4K 电视机顶盒。



#### Week 20：终极项目 - Android 12/13 源码编译与定制



*这是 BSP 开发的终极折磨与成就。*

- [ ] **拉取 Android 源码**：通常需要 200GB+ 空间，网络要求极高。
- [ ] **编译 Android**：耗时 4-8 小时。
- [ ] **定制**
  - [ ] 修改 `device/rockchip/rk3588` 下的配置。
  - [ ] 预装自己的 APK。
  - [ ] 去除不需要的系统服务，精简体积。
  - [ ] 烧录并体验流畅的 Android 桌面模式。

------



### 💡 建议的进度管理方式



建议您使用 Notion 或 Obsidian 建立一个 Kanban（看板）或 Checklist 页面。

每一项任务完成后，不仅要打钩，还要在后面附上：

1. **遇到的坑**（例如：某个库版本不对报错）。
2. **解决方法的链接**（StackOverflow 或 论坛帖子）。
3. **关键截图**。

这样 20 周下来，您拥有的不仅是一个板子，而是一份价值极高的**嵌入式 Linux 全栈工程师实战手册**。祝您玩得开心！